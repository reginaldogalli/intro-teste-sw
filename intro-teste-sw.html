<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
	<div>
		<div>
			<span>Conceitos Preliminares</span>
			<details>
				<summary>Padronização da terminologia: Engano x Defeito x Erro x Falha</summary>
				Engano  introduz =>  Defeito  produz =>  Erro  propaga =>  Falha
				<ul>
					<li>Considere o comando (z = y + x) substituído por engano pelo comando (z = y - x).</li>
					<li>Se o defeito introduzido for ativado com (x = 0):
						<ul>
							<li>Nenhum valor incorreto para a variável z é produzido.</li>
							<li>O defeito é ativado mas não produz um erro e, consequentemente, não ocorre uma falha.</li>
						</ul>
					</li>
					<li>Para qualquer outro valor de x (x != 0):
						<ul>
							<li>A ativação do defeito produz um erro na variável z.</li>
							<li>Tal erro, se propaga até a saída, caracteriza uma falha.</li>
						</ul>
					</li>
				</ul>
				A ISO/IEC/IEEE 24765:2010(E) diferencia os seguintes termos:
				<ol>
					<li><strong>Engano (Mistake)</strong> - ação humana que produz um resultado incorreto.</li>
					<li><strong>Defeito (Fault)</strong> - um passo, processo, ou definição de dados incorreta em um produto de software.</li>
					<li><strong>Erro (Error)</strong> - diferença entre o valor computado, observado ou medido e o valor teoricamente correto de acordo com a especificação.</li>
					<li><strong>Falha (Failure)</strong> - inabilidade do sistema ou componente de realizar a função requerida, considerando as questões de desempenho exigidas.</li>
				</ol>
			</details>
		</div>
		<div>
			<details>
				<summary>Etapas da atividade de teste</summary>
				<ul>
					<li><strong>Planejamento:</strong>
						<ul>
							<li>Recursos humanos, tecnológicos, estratégias de teste e critérios.</li>
							<li>Saída: Plano de teste
								<ul>
									<li>Planejamento para execução do teste; funcionalidades a serem testadas; tarefas de teste; riscos associados, cronograma, requisitos do ambiente, etc.</li>
								</ul>
							</li>
							<li>Dica de busca: modelo de plano de teste, template de plano de teste, testing plan model, testing plan template, etc.</li>
						</ul>
					</li>
					<li><strong>Projeto de casos de teste:</strong>
						<ul>
							<li>São elaborados os casos de teste com os quais o programa deve ser testado.</li>
							<li>Saída:
								<ul>
									<li>Especificação de Projeto de Caso de Teste (refina o planejamento).</li>
									<li>Especificação de caso de teste (dados de entrada, resultados esperados, ações para execução do teste).</li>
									<li>Especificação de procedimento de teste (passos para executar o conjunto de casos de teste).</li>
								</ul>
							</li>
						</ul>
					</li>
					<li><strong>Execução:</strong>
						<ul>
							<li>O programa é executado com os casos de teste elaborados.</li>
							<li>Saída:
								<ul>
									<li>Diário de teste (detalhes cronológicos de execução dos testes).</li>
									<li>Relatório de incidente de teste (qualquer evento ocorrido na execução e que precise ser analisado depois).</li>
									<li>Relatório de encaminhamento de item de teste.</li>
								</ul>
							</li>
						</ul>
					</li>
					<li><strong>Análise dos resultados:</strong>
						<ul>
							<li>Avalia-se o comportamento do programa testado, considerando os casos de teste.</li>
							<li>Saída:
								<ul>
									<li>Relatório de resumo de teste</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
			</details>
		</div>
		<div>
			<details>
				<summary>As fases da atividade de teste</summary>
				<table>
					<thead>
						<tr>
							<th>Fase</th>
							<th>Foco</th>
							<th>Erros que podem ser relatados</th>
							<th>Observação</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Teste de <strong>Unidade</strong></td>
							<td><strong>Menores unidades</strong> de um software (funções, procedimentos, métodos, classes).</td>
							<td>Erros simples de programação, estruturas de dados incorretas, algoritmos mal interpretados ou incorretos.</td>
							<td>Pode ser feito durante a implementação e pelo próprio desenvolvedor</td>
						</tr>
						<tr>
							<td>Teste de <strong>Integração</strong></td>
							<td>Construção <strong>da estrutura</strong> do software</td>
							<td>interfaces entre as unidades</td>
							<td>Feito após testar as unidades.<br>Executado pela equipe de desenvolvimento, que conhece a estrutura interna do software.</td>
						</tr>
						<tr>
							<td>Teste de <strong>Sistema</strong></td>
							<td>O <strong>sistema.</strong></td>
							<td>Erros de funções e características de desempenho que não estejam de acordo com a especificação.</td>
							<td>Feito após o sistema estar completo.<br>Pode ser feito por uma equipe independente.<br>Pode-se considerar requisitos funcionais e não funcionais (segurança, performance, etc).</td>
						</tr>
						<tr>
							<td>Teste de <strong>Regressão</strong></td>
							<td>Garantir que os requisitos testados anteriormente continuam válidos <strong>após modificações</strong> no software.</td>
							<td>Erros referente às funções que foram atualizadas</td>
							<td>Este teste é feito após as manutenções do sofwtare.</td>
						</tr>
					</tbody>
				</table>
			</details>
		</div>
	</div>
	<div>
		<details>
			<summary>Técnicas de teste</summary>
			<strong>Cenário típico da atividade de teste</strong>
			<ul>
				<li><strong>Domínio de entrada</strong> de um programa <strong>P</strong>: conjunto de todos os valores que podem ser usados para executar P;</li>
				<li><strong>Dado de teste: </strong> elemento do domínio de entrada P;</li>
				<li><strong>Caso de teste: </strong> Dado de teste + Resultado esperado => Saída obtida = Saída esperada?</li>
			</ul>
			<strong>Subdomínios</strong>
			Testar um programa com todos os elementos possíveis pode ser infactível ar grandes ou infinitos domínios de entrada. Neste caso podemos selecionar subdomínios, garantindo a alta probabilidade em revelar defeitos no software, caso existam.
			<br> Para identificar os subdomínios são definidas "regras", chamadas <strong>técnicas</strong> e seus critérios, para identificar quando dados de teste devem estar no mesmo subdomínio ou em subdomínios diferentes.
			<table>
				<thead>
					<tr>
						<th>Técnicas</th>
						<th>Tipos de informação utilizado para derivar as requisições de teste</th>
						<th>Passos principais</th>
						<th>Exemplos de critérios</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Teste <strong>Funcional</strong></td>
						<td><strong>Especificação</strong> do software</td>
						<td>a) Identificar as funções que o software deve realizar.<br>
						b) Criar casos de teste capazes de verificar se tais funções estão sendo executadas corretamente.</td>
						<td>
							<ul>
								<li>Particionamento em Classes de Equivalência</li>
								<li>Análise do valor limite</li>
								<li>Combinatorial</li>
								<li>Grafo de causa-efeito</li>
								<li>Error-guessing</li>
								<li>Teste funcional sistemático</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Teste <strong>Estrutural</strong></td>
						<td>Conhecimento da estrutura interna do programa <strong>(implementação, código fonte)</strong></td>
						<td>A maioria dos critérios desta técnica utiliza uma representação de programa conhecida como grafo de programa.</td>
						<td>
							<ul>
								<li>Critérios baseados em complexidade (McCabe)</li>
								<li>Critérios baseados em fluxo de controle (todos-nós, todos-arcos, todos-caminhos)</li>
								<li>Critérios baseados em fluxo de dados (Rapps & Wayuker; Potenciais usos)</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Técnica baseada em <strong>defeitos</strong></td>
						<td><strong>Defeitos típicos </strong>do processo de implementação de software</td>
						<td>Criar implementações alternativas e forçar o testador a projetar casos de teste que revelem os defeitos neles introduzidos.</td>
						<td>
							<ul>
								<li><strong>Teste de Mutação</strong>
									<ul>
										<li>Análise de Mutantes</li>
										<li>Mutação de interface</li>
									</ul>
								</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<br><ul>
				<li>Funcional: todas as fases de teste (unidade, integração sistema).</li>
				<li>Estrutural: fases de teste de unidade e teste de integração.</li>
				<li>Mutaação: fases de teste de unidade de teste de integração.</li>
			</ul>
		</details>
	</div>
	<span>Teste Funcional</span>
	<div>
		<details>
			<summary>Particionamento em Classes de Equivalência</summary>
			<strong>Diretrizes para definir as classes</strong>
			<ul>
				<li>Se a condição de entrada especifica um intervalo, então defini-se uma classe válida e duas inválidas.</li>
				<li>Se a condição de entrada especifica uma quantidade, então defini-se uma classe válida e duas inválidas.</li>
				<li>Se a condição especifica conjuntos determinados de valores, defini-se uma classe válida para cada conjunto e uma classe inválida com outro valor qualquer.</li>
				<li>Se a condição de entrada é específica ("deve ser assim"), então defini-se uma classe válida e uma inválida.</li>
			</ul>
			<strong>Exemplo:</strong> Um programa deve determinar se um identificador é válido ou não. UM identificador válido deve começar com uma letra e conter apenas letras ou dígitos. Além disso, deve ter no mínimo um caractere e no máximo seis caracteres de comprimento".
			<br><strong>Passo 1: Identificar as classes de equivalência</strong>
			<table>
				<thead>
					<tr>
						<th>Variáveis de entrada</th>
						<th>Classes de equivalência válidas</th>
						<th>Classes de equivalência inválidas</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Comprimento (t)</td>
						<td>1 <= t <= 6 <strong>(1)</strong></td>
						<td>t < 1 <strong>(2)</strong> e t > 6 <strong>(3)</strong></td>
					</tr>
					<tr>
						<td>Iniciar com uma letra (l)</td>
						<td>Sim, inicia com letra <strong>(4)</strong></td>
						<td>Não inicia com letra <strong>(5)</strong></td>
					</tr>
					<tr>
						<td>Contém letras ou dígitos (c)</td>
						<td>sim, só contém letras ou dígitos<strong>(6)</strong></td>
						<td>Contém caracteres diferentes de letras e dígitos<strong>(7)</strong></td>
					</tr>
				</tbody>
			</table>
			<strong>Passo 2: Definição do conjunto de casos de teste:</strong><br>
			T<sub>0</sub> = {(a5, Válido),<sub>(1), (4), (6)</sub> ("", Inválido),<sub>(2)</sub> (665432197, Inválido), <sub>(3), (5)</sub> (B*ss1, Inválido <sub>(7)</sub>)}
		</details>
	</div>
	<div>
		<details>
			<summary>Análise do valor limite</summary>
			Explora valores nos limites das classes de equivalência (sobre ou imediatamente antes ou depois dos limitadores das classes).<br>
			<strong>Recomendações gerais para a aplicação do critério análise do valor limite</strong>
			<table>
				<thead>
					<tr>
						<th>Se a condição de entrada...</th>
						<th>Exemplo</th>
						<th>...devem ser definidos dados de teste</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>(1)Especifica um intervalo de valores</td>
						<td>Um valor no intervalo entre -1 e 1.</td>
						<td>Para os limites desse intervalo e dados de teste imediatamente subsequentes, que explorem classes inválidas vizinhas:
							<ul>
								<li>-1</li>
								<li>+1</li>
								<li>-1,001</li>
								<li>+1,001</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>(2)Especifica uma quantidade de valores</td>
						<td>Um valor no tamanho de 1 até 255 caracteres</td>
						<td>
							<ul>
								<li>Com nenhum valor de entrada;</li>
								<li>Com somente 1 valor;</li>
								<li>Com 255 valores;</li>
								<li>e com 256 valores de entrada;</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<ul>
				<li>Usar a recomendação (1) para as condições de saída.</li>
				<li>Usar a recomendação (2) para as condições de saída.</li>
				<li>Se a entrada ou saída for um conjunto ordenado, preocupe-se com o primeiro e o último elemento.</li>
			</ul>
		</details>
	</div>
</body>
</html>